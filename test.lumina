Input -> VertexPass : Vector2 modelPosition;
VertexPass -> FragmentPass : int tileID;
FragmentPass -> Output : Color outputColor;

DataBlock cameraUBO as constant
{
	Matrix4x4 viewMatrix;
	Matrix4x4 projectionMatrix;
};

DataBlock modelData as attribute
{
	Matrix4x4 modelMatrix;
};

#define SizeX 16
#define SizeY 16

DataBlock chunkData as attribute
{
	int tileID[SizeX * SizeY / 2];
};

struct Tile
{
	int initialized;
	Color color;
};

DataBlock tileData as constant
{
	uint maxTileID;
	Tile tiles[];
};

int unpackTileID(int p_instanceID)
{
	const int packedIndex = p_instanceID / 2;
	const int packed = chunkData.tileID[packedIndex];

	const bool isOdd = ((p_instanceID & 1) != 0);
	const int raw16 = isOdd ? ((packed >> 16) & 0xFFFF) : (packed & 0xFFFF);

	return (raw16 >= 0x8000) ? (raw16 - 0x10000) : raw16;
}

VertexPass()
{
	int x = (InstanceID % SizeX);
	int y = (InstanceID / SizeY);

	Vector2 tilePosition = Vector2(float(x), float(y));

	tileID = unpackTileID(InstanceID);

	Vector4 localPos = Vector4(modelPosition + tilePosition, 0.0, 1.0);
	Vector4 worldPos = modelData.modelMatrix * localPos;

	Vector4 viewPos = cameraUBO.viewMatrix * worldPos;
	Vector4 clipPos = cameraUBO.projectionMatrix * viewPos;

	pixelPosition = clipPos;
}

Tile getTile(int tileID)
{
	if (tileID < 0 || tileID >= tileData.maxTileID)
	{
		discard;
	}

	Tile tile = tileData.tiles[tileID];

	if (tile.initialized == 0)
	{
		discard;
	}

	return (tile);
}

FragmentPass()
{
	Tile tile = getTile(tileID);

	outputColor = tile.color;
}